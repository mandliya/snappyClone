#ifndef SNAPPY_H
#define SNAPPY_H

#include "snappy-stubs-public.h"

namespace snappy {
	class Source;
	class Destination;

	//Generic Compression/Decompression routines

	//Compress the bytes read from "*source" and append it to "*destination".
	//Return the number of bytes written
	size_t Compress(Source *source, Destination *destination);

	//Find the uncompressed length of the given stream, as provided by header.
	//Note that the true length could deviate from this; the stream could eg. be truncated.
	//Also to note is that this leaves "*source" in a unsuitable state for further operations
	//such as RawUncompress()
	//We will need to rewind or recreate the source ourselves before attempting any further calls.
	bool GetUncompressedLength(Source *source, uint32* result);

	//-----------------------------------
	//Higher level string based routines
	//-----------------------------------

	//Purpose:	Sets "*output" to compressed version of "input[0, input_length-1]".
	//			Contents of the "*output" before are lost.
	//Requires: "input[]" is not an alias of "*output".
	size_t Compress(const char* input, size_t input_length, string* output);

	//Purpose:	Decompresses "compressed[0, compressed_length-1]" to "*uncompressed"
	//			Original contents of "*uncompressed" is lost.
	//Requires: "compressed[]" is not an alias of "*uncompressed"
	bool Uncompress(const char* compressed, size_t compressed_length,
					  string* uncompressed);

	//Purpose:	Decompresses "compressed" to "uncompress"
	//Returns:	returns false if the message is corrupted or could not be decompressed
	bool Uncompress(Source *compress, Destination *uncompress);

	//Purpose:	Uncompresses as much of the "compressed" as possible
	//			into destination. It returns number of valid bytes added to the destination.
	//			(Extra invlid bytes might have been added due to errors, the caller should ignore those)
	//			The emitted data type typically has length GetUncompressedLength(),
	//			but may be shorter if an error is encountered
	size_t UncompressAsMuchAsPossible(Source * compressed, Destination * uncompressed);

	//---------------------------------------------------------
	//Lower level character array based routines.
	//They may be useful for efficiency reasons in some cases.
	//---------------------------------------------------------

	//Purpose:	Takes the data stored in "input[0..input_length]" and stores it array pointed to by "compressed".
	//			"*compressed_length" is set to the length of the compressed output.
	//Requires:	"compressed" must point to an area of memory that is at least "MaxCompressedLength(input_length)"
	//			bytes in length.
	//Example:
	//			char * output = new char[snappy::MaxCompressedLength(input_length)];
	//			size_t output_length;
	//			RawCompress(input, input_length, output, &output_length);
	//			....Process(output, output_length)...
	//			delete[] output.
	void RawCompress(const char * input,
					 size_t input_length,
					 char *compressed,
					 size_t* compressed_length);


	//Purpose:	Given data from byte source "compressed" is generated by calling Snappy::Compress
	//			this routine stores the uncompressed data to uncompressed[0..GetUncompressedLength(compressed, compressed_length)-1]
	//Returns:	False if the compressed is corrupted and could not be decrypted
	bool RawUnCompress(Source *compressed, char* uncompressed);

	//Purpose:	Given data in "compressed[0..compressed_length-1]" is generated by calling
	//			Snappy::Compress routine, this routine stores the uncompressed data to iovec "iov".
	//			The number of physical buffers is given by iov_cnt and their cumulative size must be at least
	//			GetUncompressedLength(compressed).
	//Requires:	The individual buffers in "iov" must not overlap each other
	//Returns:	False if compressed is corrupted or could not be decrypted
	bool RawUnCompressToIOVec(const char* compressed, size_t compressed_length,
							  const struct iovec* iov, size_t iov_cnt);

	//Purpose:	Provides maximum size of the compressed representation of the input data that is "source_bytes" bytes in length
	size_t MaxCompressedLength(size_t source_bytes);

	//Purpose:	Returns true and stores the length of uncompressed data in *result normally.
	//			Returns false on parsing error. This operation takes o(1)
	//Requires:	"compressed[]" was produced by RawCompress() or Compress()
	bool GetUnCompressLength(const char* compresed, size_t compressed_length,
							 size_t* result);

	//Purpose:	Returns true iff contents of "compressed[]" can be uncompressed successfully.
	//			Does not return uncompressed data. Takes time proportional to compressed_length, however
	//			is usually atleast a factor of four faster than actual compression
	bool isValidCompressedBuffer(const char* compressed,
								 size_t compressed_length);

	//Purpose:	Returns true iff contents of "compressed" can be uncompressed successfully.
	//			Does not return uncompressed data. Takes time proportional to compressed_length, however
	//			is usually atleast a factor of four faster than actual compression
	//			On success, consumes all of the *compressed, On failure, consumes an unspecified prefix of *compressed.
	bool isValidCompressed(Source *compressed);

	//Purpose:	The size of a compression block
	//Notes:	Many part of the compression code assumes that kBlockSize <= 65536;
	//			In particular, the hash-table can only store 16-bit offsets, and EmitCopy()
	//			also assumes the offset is 65536 bytes or less. Note that if you change this,
	//			it will affect the framing_format. (Refer framing_format.txt)
	static const int kBlockLog = 16;
	static const size_t kBlockSize = 1 << kBlockLog;

	static const int kMaxHashTableBits = 14;
	static const size_t kMaxHashTableSize = 1 << kMaxHashTableBits;
} //end of namespace snappy

#endif //SNAPPY_H